<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="style.css">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dream Timeline</title>
</head>
<body>
  <!-- Header will be injected -->
  <div id="loading-overlay">
    <div class="spinner"></div>
  </div>

  <div class="timeline" id="timeline"></div>

  <div id="popup" style="display: none;"></div>

  <button class="post-fab" onclick="goToTop()">Post</button>

  <!-- Footer will be injected -->

<script type="module">
import { createDreamCard } from './dreamCard.js';
import { createHeader } from './header.js';
import { createFooter } from './footer.js';
import { showNotification, hideNotification } from './notification.js'; // new notification system

const API_URL = 'https://stardriftr-api.calembeaz.workers.dev/dreams';
const timeline = document.getElementById('timeline');

// Inject header and footer
document.body.prepend(createHeader());
document.body.appendChild(createFooter());

function goHome() { window.location.href = "index.html"; }
function goToTop() { window.location.href = 'index.html'; }
function showPopup(msg) {
  const popup = document.getElementById("popup");
  popup.textContent = msg;
  popup.style.display = "block";
  setTimeout(() => popup.style.display = "none", 3000);
}

function randomEmoji() {
  const emojis = ['😴', '🌌', '👁️', '🌀', '🌙', '🛌'];
  return emojis[Math.floor(Math.random() * emojis.length)];
}

function fallbackAnon(i) {
  return 'Anon-' + String(1000 + i);
}

async function loadTimeline() {
  const loadingOverlay = document.getElementById('loading-overlay');
  loadingOverlay.style.display = 'block';
  try {
    const res = await fetch(API_URL);
    if (!res.ok) throw new Error(`Failed to fetch timeline: ${res.status}`);
    const dreams = await res.json();
    timeline.innerHTML = '';
    dreams.sort((a,b) => Number(b.time)-Number(a.time))
          .forEach((d,i) => {
            const card = createDreamCard(d,i);
            if (card) timeline.appendChild(card);
          });
  } catch(err) {
    console.error(err);
    showPopup("Error loading timeline: " + err.message);
  } finally {
    loadingOverlay.style.display = 'none';
  }
}

async function postPendingDream() {
  const selectedDream = localStorage.getItem('selectedDreamText')?.trim();
  const pendingDream = localStorage.getItem('pendingDream')?.trim();
  const generateImage = localStorage.getItem('generateImage') === 'true';
  const uid = localStorage.getItem('uid')?.trim();

  // Only show notification if there’s a real pending dream
  if (selectedDream && pendingDream && uid) {
    showNotification("Dream uploading...", { bottom: 70 });
  }
  console.log("🔄 Posting dream:", {uid, pendingDream, selectedDream, generateImage});

  try {
    const dreamRes = await fetch(API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        uid,
        pendingDream,
        selectedDreamText: selectedDream,
        generateImage
      }),
    });

    if (!dreamRes.ok) throw new Error(`Failed to post dream: ${dreamRes.status}`);
    const dreamData = await dreamRes.json();
    console.log("✅ Dream posted:", dreamData);

    // Clear localStorage so it doesn’t re-post
    localStorage.removeItem('selectedDreamText');
    localStorage.removeItem('generateImage');
    localStorage.removeItem('pendingDream');

  } catch (err) {
    console.error("❌ Error posting dream:", err);
    showPopup("Failed to post dream: " + err.message);
  } finally {
    hideNotification();
  }
}

// ---------- Handle both first load and bfcache navigation ----------
window.addEventListener('pageshow', async (event) => {
  if (event.persisted || !document.wasPosted) {
    await loadTimeline();
    await postPendingDream();
    document.wasPosted = true;
  }
});
</script>
</body>
</html>

